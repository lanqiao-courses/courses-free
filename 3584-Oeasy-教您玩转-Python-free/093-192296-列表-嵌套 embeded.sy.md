---
show: step
version: 1.0
enable_checker: true
---

# 列表 - 嵌套 embedded

## 回忆

- 这次我们了解了排序
- 排序是在原来的列表上做的
- 可以按照不同的方式排序
- 可以递增也可以逆序
- 排好序之后插入就更合理了 🤔
- 最重要的是列表里面还可以放列表

### 列表嵌套

- 列表的嵌套其实就是列表里面放了另一个列表

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210915-1631698136680)

- 中括号就是索引操作
- 取得第几个元素

### 降维

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210921-1632221168291)

- 本来 l 是一个 3\*3 的数组
- 对他进行了索引操作[0]
- 得到了这个二维数组的第一个元素
  - 一个一维数组[1, 2, 3]
  - 可以继续进行其他运算

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210921-1632221501057)

- 这样就可以再对 a[0]这个一维数组进行
  - 索引操作
  - 切片操作
- 这就是先索引然后再对一维数组进行操作
- 那我可以先切片吗？

### 切片操作

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210921-1632221737969)

- 二维数组先切片
- 得到的还是一个二维数组
  - 是按照行切出来的
- 再切片得到的还是二维数组
  - 还是按照行切出来的
- 可以对这个二维数组
  - 再进行切片或者索引的操作
- 这是不断把数组缩减或者降维的过程

### zip

- zip 可以把若干列表同一位置的元素压在一起

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210915-1631698184099)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210915-1631698233000)

- l1 有 l1[3]
- l2 没有 l2[3]
- 所以 zip 停止在
- 第 2 个元素
- 因为 l2 没有 第 3 个元素

### 列表嵌套

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631623493488)

- x 最开始是一个列表
  - 列表里面有一个列表
  - 内部列表有个元素是 0
- 然后 x 乘以 3
  - [[0],[0],[0]]
- x[0]是[0]
- 添加 1 之后是[0,1]
- 可是为什么 x[1]、x[2]都是  [0,1]呢？

### 观察

- x =[[0]]

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631623686937)

- x = x \* 3

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631623716306)

- x 是一个列表
- x 列表里面有三个元素
- 三个元素都是列表
- 都指向同一个列表
- 这个列表是[0]

### 附加 append

- 关键的一步来了

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631623810957)

- x[0].append(1)
- x[0] 附加 append 了 1
- x[0]、x[1]、x[2]指向同一位置
- 所以 x 就是
  - [[0, 1], [0, 1], [0, 1]]
- 但是如果我一开始初始化 x 的方式为
  - x = [[0], [0], [0]]呢？

### 结果

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211126-1637924664867)

- 这和刚才的这个完全不同啊？
- 为什么呢？

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631623493488)

### 原因分析

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211126-1637924709657)

- 这个关于内存的细节有点意思啊
- 列表里面什么类型都能放吗？
- 不但可以放列表
- 还可以放字符还可以放字符串
- 那可以混着放点浮点数啥的么？

### 来试试

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630230471457)

- 列表项可以是不同类型的东西

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630230508598)

- 那这样可以进行赋值么

### 赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630230563086)

- 像正常列表一样
- 两个列表变量指向同一个 heap 堆空间的列表地址
- 我想要两个列表
  - 虽然相同
  - 但得是两个列表

### copy

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630230673754)

- 使用 copy 可以获得一个浅拷贝
- 确实可以得到两个列表
- 虽然相同
- 但是是两个列表
- 列表可以做列表项么？

### 嵌套 embedded

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630230764789)

- 看起来是可以的
- l_people 是一个列表
  - 里面有两个元素
  - 第一个指向 l_oeasy 的地址
  - 第二个指向 l_o2z 的地址
- 这个列表到底什么样？

### 索引嵌套元素

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210830-1630287240794)

- l_people 有两个列表项
  - 第一个指向 l_oeasy 的地址
  - 第二个指向 l_o2z 的地址
- l_oeasy 有三个列表项
  - "oeasy"
  - 2
  - 3.5
- 这个嵌套的列表 l_people 可以拷贝么？

### 浅拷贝

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630231778001)

- l_people2 确实拷贝了 l_people
- 但是 l_people2[0]和 l_people[0]指向同一个地址
- 他拷贝的只是地址
- 很浅
- 浅的问题是
  - l_people2[0]和 l_people[0]指的是一个位置
  - 一改全改
- 所以叫做浅拷贝
- 有浅就有深
- 怎么让拷贝很深呢？

### 深拷贝

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630231994247)

- 就点第一个
- 他比较了=、浅拷贝、深拷贝
  - = 直接把地址给赋过去
  - 浅拷贝 把里面元素都拷贝出来 做成新的 list 赋过去
    - 不过如果里面的元素是地址
    - 那就复制地址
  - 深拷贝
    - 彻底复制地址里面指向的每一个东西

### 比较

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630232036597)

### 具体操作

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630232261186)

- 有深有浅才有意思啊
- 不太明白也没事
- 以后还会遇到的吧
- 记住
- 要知深浅
- 退回来
- 可以试试 append 么？

### 添加

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630230908462)

- 可以添加列表项
- 目前的列表项都有一定的规律
- 很像以前做的序列化的东西
- 再试试删除

### 删除

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630231020520)

- 删除成功
- 由于 l_oeasy 还指向他
- 所以这个列表地址的数据不会被回收

### 换一个删除

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630231118686)

- 因为没有引用指向 o3z 的列表
- 所以就直接删除了
- 试试排序

### 排序

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630231202369)

- 排序 sort
- 翻转 reverse
- 都是可以做的
- 运算可以做么
- 加法乘法之类的

### 运算

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630231358942)

- 运算也是可以做的
- 但是指向的还都是那两个基础列表
- 为了清楚起见
- 我们修正一下

### 更加明确

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630231528806)

- 在此基础上

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211127-1637985344364)

- 但我想指向四个不同的人

### 深度拷贝

- 四个不同的人
- 原来的俩人
- 再加上深度拷贝新得到的俩人

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630232490472)

- 如果想要四个全新的人呢？

### 更深度

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630232515299)

- 前俩是深度拷贝出来的人
- 后俩也是
- 目前的数据结构还比较明确

### 深浅

- 浅拷贝的意思是
  - 整体上变量拥有自己的独立地址
  - 但是内部元素地址依旧指向原位置
- 深拷贝的意思是
  - 不光整体变量拥有独立空间和地址
  - 且内部元素也有自己的独立地址，不共用
- 这和元素的层次有关系
- 来看个复杂层次的例子

### list 嵌套

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630241545363)

- 这么深的层次的话
- 深拷贝都能一层层复制出来么？

### 深拷贝的威力

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211128-1638063431697)

- 确实
- 深拷贝确实够深的

### 总结

- 这次我们了解了列表的嵌套
- 列表项也可以是列表
- 可以无限嵌套下去
- 这列表仍然可以做列表能做的事情
  - 插入
  - 删除
  - 排序
  - 运算
- 不过赋值的时候注意有三种情况
  - = 复制地址
  - 浅拷贝 拷贝元素内容
  - 深拷贝 把地址里的东西都复制出来
- 这就是列表！
- python 中到处都在用的列表 list
- 但是我们经常要用的就是列表
- 还有什么好玩的么？🤔
- 下次再说 👋
