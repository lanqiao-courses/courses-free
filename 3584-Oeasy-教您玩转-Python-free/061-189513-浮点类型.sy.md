---
show: step
version: 1.0
enable_checker: true
---

# 浮点类型

## 回忆

- 这次观察余数细节
- 有三种取整方法
  - 向上天花板
  - 向下地板
  - 四舍五入
- 整除取余数用的都是向下地板法
- 如果不用整除的话，会如何呢？
- 不用整除的话，商很可能是一个小数
- 那这小数到底是怎么使用的呢？🤪

## 小数细节

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629446578924)

- 小数使用基本上是 ok 的
- 但是有的时候也会出现无法理解的情况

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629446614955)

#### 观察

- 观察数据类型

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629446662095)

- 数据是 float 类型的
- 什么是 float 呢？
- help(float)

#### 浮点类型 float

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211029-1635515488500)

- float 类里面有个成员函数 hex

#### 二进制形态

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629446954069)

- p 的意思是小数点 point
- p 前面的是有效数字
  - 可以有正负号
  - $0x$ 说明是 16 进制的表示法
- p 后面是指数
  - 小数点浮动位置
  - $-4$ 就是左移 4 位
  - $+1$ 就是右移 1 位
  - 指数变化会造成数量级的翻番
    - 在 2 的底数基础上翻番
- 因为小数点 point 可以浮动 float
  - 所以这种类型叫做浮点数 floating-point number

#### 特别注意

- float 是一个类的名字
- 最好不要用他作为变量名
- 因为
  - 一旦 float 作为一个变量理解
  - 就不能使用 float 函数把字符串转化为浮点型了

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630200328957)

- 这个原理和 str、int 等类一样
  - 而且浮点型变量的精度要低于整型变量
  - 这听起来很难以置信
  - 我们来看看

## 精度问题

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211003-1633222609130)

- 真的发生了
  - 浮点型数字精度低于整型数字
- 为什么呢？

  - 单精度浮点型数字只有 4 个字节
  - 双精度浮点型数字有 8 个字节
  - 有效数字位数有限
  - 所以...

- 浮点型数字被截断了...
  - 最上面的图可以看出丢失了一位精度
  - 而且最后一位 9 还给舍了
- 具体是怎么截断的呢？

#### 验证

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629447597089)

- $1.0$ 对应 `\x3f\x80\x00\x00`
- 这个规则叫做 ieee754 32-bit 浮点数
- 存储在四个字节
- "$>f$"为什么可以把二进制形态改变？
- 这涉及到一个东西叫做
  - 字节序

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211029-1635516032723)

#### 字节序对比

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635559712503)

#### little-endian

- $<f$ 用的是小字节序
  - 编码模式属于 small-endian
  - 最低有效位（least significant byte）放在低地址 a

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635559260042)

- 这是目前 CISC 指令集架构 ($x86、x86-64$) 用的字节序
- 另一种字节序是大字节序

#### big-endian

- > f 是按下图中的字节排序
  - 编码模式属于 big-endian
  - 最高有效位（most significant byte）落在低地址

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635559602632)

- 这是目前 RISC 指令集架构 (RISC、MIPS) 用的字节序
- 这也是我们看起来比较顺的字节序
- 如下图所示

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211105-1636108485829)

- http://www.binaryconvert.com/result_float.html?hexadecimal=3F800000

## 继续验证

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629447889894)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629447904479)

- $2.0$ 和 $1.0$ 相比
  - 指数部分 $+1$
  - 尾数部分没有变化

**$4.0$：**

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448007718)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448017365)

- $4.0$ 和 $2.0$ 相比
  - 原基础上又 $x2$
  - 相当于指数 $+1$
  - 尾数没有变化
- 如果是 $0.5$ 呢？

**$0.5$：**

- $0.5$ 是在 $1.0$ 的基础上除以 2
- 相当于在 $1.0$ 的指数部分 $-1$

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448346168)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448317994)

- 指数部分从 $1.0$ 的 `\x3f\x80` 到 $0.5$ 的 `\x3f\x00`

#### 尾数部分

- 尾数怎么用呢？
- 回到 $1.0$
- 然后观察 $1.5$

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448678597)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448693253)

- $1.5$ 和 $1.0$ 相比
  - 指数没有变化
  - 尾数把第一位改成了 1
- $(1.1)$ <sub>2</sub> 等于 $(1.5)$<sub>10</sub>

- $3.0$ 和 $1.5$ 相比
  - 尾数没有变化
  - 指数 $+1$
  - 相当于乘以 $2$

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448861896)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448872411)

## 负数呢

- $-3.0$ 和 $3.0$ 相比
  - 指数和尾数都没有变化
  - 符号位从 $0$ 变 $1$
  - 意味着这是负数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448971211)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448962448)

#### 浮点数总结

- 浮点数有三个部分组成
  - 符号位
    - 负责正负
    - $0$ 就是正
    - $1$ 就是负
  - 指数部分
    - 负责翻倍
    - 以 $01111111$ 为平衡位置
    - $+1$ 相当于乘以 $2$
    - $-1$ 相当于除以 $2$
  - 尾数部分
    - 前面有一个 $1$ 不显示
    - 默认就是 $1.0$
    - 第一位写一个 $1$ 代表 $1.1$
    - 第二位再写一个 $1$ 代表 $1.11$
- 那我们回来再看看 $0.1$

#### $0.1$

- 最初的问题是 3 个 $0.1$ 相加等于 $0.30000000000000004$
- 观察 $0.1$

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629449640633)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629449649321)

- 这个算出来
- 比 $0.1$ 还小呢
- 不可能超过 $0.3$🤪

## 双精度

- 我们前面介绍的都是单精度浮点型 float
  - 单精度浮点型 float 总共 4 位
- 还有一种双精度浮点型 double
  - 总共 8 位

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629449849303)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629449826665)

- 那为什么加起来是 $0.30000000000000004$ 呢？
- 我们先来看看和的双精度数的二进制形态

#### 和的形态

- $0.1+0.1+0.1$ 的双精度形态
- `\x34\x33\x33\x33\x33\x33\xd3\x3f`

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629452878843)

- `\x34\x33\x33\x33\x33\x33\xd3\x3f` 对应十进制
- $0.30000000000000004$
- 前后都能说通
- 可是，这个和 $0.1$ 到底是怎么加的呢？

#### 计算

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629454276318)

- 首先获得 $0.1$ 的双精度浮点型的二进制形态
- 刨去前面的符号位和指数部分
- 还剩下总共 52 位 2 进制数
  - 如上图选中的数字部分
- $1001100110011001100110011001100110011001100110011010$
- 把这个数字复制下来

#### 补位

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635563873405)

- 有效数字前面有个缺省的 1
  - 把这 52 位 2 进制数前面补 1
  - $11001100110011001100110011001100110011001100110011010$
  - 然后乘以 3、除以 4，相当于向右移动两位
  - 为的是形成 $1.XXXX$ 的有效数字形态
  - 结果向上取整
- 然后转化为 16 进制
  - $0x3333333333334$
  - 依然是 52 位 2 进制数
  - 共 13 位 16 进制数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635564179195)

- 与 $0.1+0.1+0.1$ 得到的 $0.30000000000000004$
- 对比直接进行的二进制编码

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635564281409)

- 这是一致的
- 我可以手算这个过程么？
- 说干就干，走起来~

### 手算

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629454276318)

- 把后 52 位复制出来

#### 计算过程

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211003-1633223204797)

- 第一步是相加
- 两个一样的数，左移 1 位
- 然后再加上自身
- 得到结果是尾数
- 尾数以 $1.xxx$ 开头
- 向右移动 2 位
- 然后掐头去掉开头默认的 1
- 结尾多出的两位有进位
- 保持 52 位

#### 浮点运算进化

- 早年间其实 Guido 的 python 是这样的
  - 整型变量可以和整型变量运算
  - 浮点型变量可以和浮点型变量运算
  - 整型和浮点型之间不能加减乘除
  - 为什么呢？

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630842627155)

#### 原因

- 指令集不同
  - 整型数字加法有自己的指令集
  - 浮点型数字加法有自己的指令集
  - 没有一个指令能算整型加上浮点型
  - 要在系统里把整型转化为浮点型
  - 再用浮点型指令集来做
- 早年间甚至有专门负责浮点运算的协处理器
- 想象一下 $1e100 + 1e-100$
  - 有效数字需要对齐

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630842827722)

#### 解决

- 这个东西虽然有了指令
- 但是还是比较复杂的
- 解决这个问题的是 Tim Peters，美国的一位软件工程师
- 他在 Python 发展的早期，就参与了这个语言的开发和设计。

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630808360683)

- 他原来在为大型主机写编译器
- 后来业余时间加入了 python 这个项目
- 他是 Python 语言以及 CPython 的主要 contributor 之一
- 他创造了 Timsort hybrid sorting 算法
- 这个算法从 Python2.3 开始就在使用
- 很硬核
- 原来的整型和浮点型不能相加减
- 他让两个不同类型的数字可以相加
- Python 标准模块中的 doctest 和 timeit，也是他的大作
- 他也是 python 之禅的作者

## python 之禅学

- 2001 年秋，Foretec（一家会议组织公司）正在准备召开第十届 International Python Conference（IPC 10，Pycon 的前身）
- Foretec 打算征集一条印在会议 T 恤衫上的标语，最终他们从 Python 社区收到了 500 多条投稿
- Foretec 邀请了 Python 的核心开发 Guido，Fred，Jeremy，Tim Peters，Barry 等来担任评审
- 评审委员们从投稿中过滤出了 130 多条后就一直没有进展，直到会议快要召开时他们也没有确定最终标语
- 在会议就要开始的前几天，到了评审们不得不做出决定的时候了
- 于是由 Tim Peters 和 Barry 两人轮流评审，每人每次淘汰一半留下一半，直到最后只剩一条
- 最终，“import this”被选了出来，大家对“import this”非常满意
- 但是当选择了这条以后，他们意识到他们必须要实现它
- 经过简单的讨论后，“import this”的被定为输出 Tim Peters 写的《The Zen of Python》
- ——Python 编程和设计的指导原则。
- this.py 在 lib 里面是标准库
- 去找一下

#### 查找

- `sudo find / -name "this.py"`

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630809456883)

- 这是啥？

#### 解码

- 代码中的 s 字符串使用了 rot13 加密
- rot13 就是凯撒密码的一种，每个字母变换为它后面的第 13 个字母

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630809549374)

- 等到 IPC 10 结束后
- 他们悄悄的把代码提交到 Python 2.2.1
- 过了一段时间，才逐渐有人发现“import this”这个彩蛋

## 总结

- 这次了解浮点类型变量
- 有两种表示法
  - float 4 字节 单精度浮点型
  - double 8 字节 双精度浮点型
- 浮点型特点
  - 第一位都是符号位
  - 小数点都浮动
  - 浮动程度由指数部分决定
  - 尾数部分默认 1 开头
  - 后面的小数部分是有效数字
- 这就是浮点类型的数据
- 不过很容易出错
- 有没有减少出错的方法？🤪
- 下次再说 👋
