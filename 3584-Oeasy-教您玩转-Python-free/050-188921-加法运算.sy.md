---
show: step
version: 1.0
enable_checker: true
---

# 加法运算

## 回忆上次内容

- 上次总结了四种进制的转化公式
  - bin 前缀 0b 二进制
  - oct 前缀 0o 八进制
  - hex 前缀 0x 十六进制
  - dec 无前缀 十进制
- 数字 41 和字符串"41"的不同
- 数字 41
  - 转化为 二进制 0b101001
  - 两个字节前面补零
  - `\x00\x29`
- 字符串"41"
  - 两个字符
  - 字符转化为 ASCII 序号
  - `\x34\x31`
- 字符串型和数字型变量是可以相互转化的
- 数字型变量最重要的是可以真的做运算
- 字符串计算只是简单拼接
- 具体怎么计算？🤔

### 1+2

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210818-1629241187084)

- 太简单了，这题我会
- 其实，这个问题也有人研究
- 还研究出了名堂
- 我小的时候，老看书，成了书呆子
- 我妈就说这孩子整个一个陈景润
  - 大意就是只会学习，偏才
- 陈景润就是研究 1+2 的人
  - 任一充分大的偶数都可以表示成二个素数的和
  - 或是一个素数和一个半素数的和
- 当时以为是一个只会数学没有生活能力的 nerd
- 现在反思他能成为我妈都能知道的红人就很厉害
- 这源于徐迟的报告文学《哥德巴赫猜想》
  - 各地报纸、广播电台纷纷全文转载和连续广播
  - 是一本文学色彩很强的报告文学
  - 在特定阶段有指明方向的意义
  - 他能够配合宣传、把握机会
  - 造就了当时的传奇

#### 思考人生

- 早期陈景润作为中学教师
  - 就给当时的数学大师华罗庚写信获得发现和提拔
- 早期的华罗庚用今天的观点看
  - 20 岁还是初中毕业
  - 身患残疾靠自学成才
  - 在《科学》指出讨论苏家驹论文中的错误
  - 获得清华教授关注
  - 进入清华

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210818-1629245372996)

- 他们都是
  - 知道当时信息传播的基本走向和模式
  - 能够抓住传播的核心节点
  - 善于利用当时的主流媒体
  - 并能最终把握机会的人
- 世界是普遍联系的
- 时代虽然是不断变化的
  - 执今之道 以御今之有 以知古始 是谓道纪
- 我们来一下十以内加法

### 十以内加法

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210818-1629244750043)

- 这就是两个数字相加
- 并求出结果
- 可是他们不是都用二进制存储么？
- 理论上应该也是用二进制相加？
- 我把他们转化为二进制

#### 二进制加法

- 10 进制加法
  - $3_10+8_10 = 11_10$
- 2 进制加法
  - $(0b11)_2+(0b1000)_2 = 0b1011_2 = 11_10$

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210818-1629244934224)

- 无论
  - 你用两个手指数
  - 还是用十个手指数
  - 瓜就是那么多的瓜
  - 和你有几根手指没关系
  - 只是数的方法不同
  - 不影响瓜得多少

#### 加法过程

- 加法是一个运算 operation
- 加号是一个运算符 operator
- 运算符两边是操作数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210818-1629250201327)

#### 语法结构

- 加法运算包括
  - 加法运算符
  - 左操作数
  - 右操作数
- 这两种加法会有什么不同的结果么？

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210818-1629250211822)

- 试试看

#### 结果

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211104-1635983442456)

- 结果就是这么一个结果
- 可是这是为什么呢？
- 加法都是加法
- 为什么结果不同呢？

### 数据类型

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211104-1635983539954)

- 他们的数据类型不一样
- 数字相加得到数字
- 字符串相加得到字符串
- 虽然都是加法
- 但是因为操作数的不同
  - 加的方式不同

#### 变量加法

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210818-1629250696962)

- iLeftOperand
  - i 整型数字
  - LeftOperand 左操作数
- iRightOperand
  - i 整型数字
  - RightOperand 右操作数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210818-1629250955072)

#### 变量位置

- 左操作数
  - 放在内存 10894432 位置开头的字节里
  - 内存情况是`\x00\x03`
  - 用数字变量的方式存的 int 型变量
  - 可理解为十进制的 3
- 右操作数
  - 放在内存 10894592 位置开头的字节里
  - 内存情况是 `\x00\x08`
  - 用数字变量的方式存的 int 型变量
  - 可理解为十进制的 8

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211104-1636000951607)

- 实验中的 id 地址和图中的不一样很正常
- 因为内存情况是不一样的呀

#### 加法指令

- 左右操作数都从内存读出来之后
- 放在 cpu 寄存器里面
- 加法肯定执行的是 cpu 的加法指令
  - 回忆一下我们把 python 可执行文件反汇编的过程
  - 执行加法指令的时候 cpu 电路是一个全加器 🧮
- 都准备好了
- 咔一加
- 加出来的结果放在寄存器里
- 可是没有地方接着这个加法结果
- cpu 会继续执行下一条指令
- 我想把加法结果存住怎么办？

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210818-1629251648307)

## 赋值运算

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210818-1629251655800)

- 过程是
  - 声明一个变量 iSum
    - i 指的是 integer 型变量
    - Sum 说明他是一个和
  - iSum 接收加法运算的结果
  - iSum 确实是一个 int 型变量
  - 在内存中的位置是 10894688
  - 把加法的结果赋给 iSum
- 其实是 $iSum ← (iLeftOperand + iRightOperand)$
- 具体的值是 `\x00\x0b`
  - (0xa)<sub>16</sub> 相当于 (10)<sub>10</sub>
  - (0xb)<sub>16</sub> 相当于 (11)<sub>10</sub>
- 电脑算的没毛病！😝

### 总结

- 这次开始了真正的运算
  - 加法运算
  - 加法运算由运算符和操作数组成
  - 加法操作实际是 cpu 的加法指令
  - 加法的结果赋给一个接收变量
- 更复杂的运算
  - 也可以做

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210818-1629244632089)

- 我想输入被加数和加数
- 然后让电脑计算
- 可以么？🤔
- 下次再说 👋
