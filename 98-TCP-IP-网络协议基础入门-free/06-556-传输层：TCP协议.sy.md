---
show: step
version: 1.0
enable_checker: true
---

# 传输层：TCP 协议

## 实验简介

上节实验我们学习了传输层协议的 UDP 协议，本节我就来学习更复杂的 TCP 协议。

TCP 和 UDP 处在同一层——传输层，但是它们有很多的不同。TCP 是 TCP/IP 系列协议中最复杂的部分，它具有以下特点：

- TCP 提供 **可靠的** 数据传输服务，TCP 是 **面向连接的** 。应用程序在使用 TCP 通信之前，先要建立连接，这是一个类似“打电话”的过程，通信结束后还要“挂电话”。
- TCP 连接是 **点对点** 的，一条 TCP 连接只能连接两个端点。
- TCP 提供可靠传输，无差错、不丢失、不重复、按顺序。
- TCP 提供 **全双工** 通信，允许通信双方任何时候都能发送数据，因为 TCP 连接的两端都设有发送缓存和接收缓存。
- TCP 面向 **字节流** 。TCP 并不知道所传输的数据的含义，仅把数据看作一连串的字节序列，它也不保证接收方收到的数据块和发送方发出的数据块具有大小对应关系。

#### 知识点

- TCP 报文段结构
- 连接的建立与释放
- TCP 可靠传输的实现
- 超时重传
- 连续 ARQ 协议
- 流量控制和拥塞控制
- tcpdump 抓取 TCP 报文段

## 实验步骤

使用 `netstat -s` 查看数据包统计信息：

以下截图截取 tcp 部分

![图片描述](https://dn-simplecloud.shiyanlou.com/uid/8797/1545649901765.png-wm)

> 截图中每行所表示含义依次是：主动开放的连接数，被动开放的连接数，失败的连接尝试，重置连接数，当前连接数，接收的 分段数，发送的分段数，重新传输的分段数。

### TCP 报文段结构

TCP 是面向字节流的，而 TCP 传输数据的单元是 **报文段** 。一个 TCP 报文段可分为两部分：报头和数据部分。数据部分是上层应用交付的数据，而报头则是 TCP 功能的关键。

TCP 报文段的报头有前 20 字节的固定部分，后面 4n 字节是根据需要而添加的字段。如图则是 TCP 报文段结构：

![图片描述](https://dn-simplecloud.shiyanlou.com/uid/8797/1548921882697.png-wm)

20 字节的固定部分，各字段功能说明：

- `源端口和目的端口`:各占 2 个字节，分别写入源端口号和目的端口号。这和 UDP 报头有类似之处，因为都是传输层协议。
- `序号`:占 4 字节序，序号范围[0，2^32-1]，序号增加到 2^32-1 后，下个序号又回到 0。TCP 是面向字节流的，通过 TCP 传送的字节流中的每个字节都按顺序编号，而报头中的序号字段值则指的是本报文段数据的**第一个字节的序号**。
- `确认序号`:占 4 字节，期望收到对方下个报文段的第一个数据字节的序号。
- `数据偏移`:占 4 位，指 TCP 报文段的报头长度，包括固定的 20 字节和选项字段。
- `保留`:占 6 位，保留为今后使用，目前为 0。
- `控制位`:共有 6 个控制位，说明本报文的性质，意义如下：
  - `URG 紧急`:当 URG=1 时，它告诉系统此报文中有紧急数据，应优先传送(比如紧急关闭)，这要与**紧急指针**字段配合使用。
  - `ACK 确认`:仅当 ACK=1 时**确认号**字段才有效。建立 TCP 连接后，所有报文段都必须把 ACK 字段置为 1。
  - `PSH 推送`:若 TCP 连接的一端希望另一端立即响应，PSH 字段便可以“催促”对方，不再等到缓存区填满才发送。
  - `RST复位`:若 TCP 连接出现严重差错，RST 置为 1，断开 TCP 连接，再重新建立连接。
  - `SYN 同步`:用于建立和释放连接，稍后会详细介绍。
  - `FIN 终止`:用于释放连接，当 FIN=1，表明发送方已经发送完毕，要求释放 TCP 连接。
- `窗口`:占 2 个字节。窗口值是指发送者自己的**接收窗口**大小，因为**接收缓存**的空间有限。
- `检验和`:2 个字节。和 UDP 报文一样，有一个检验和，用于检查报文是否在传输过程中出差错。
- `紧急指针`:2 字节。当 URG=1 时才有效，指出本报文段紧急数据的字节数。
- `选项`:长度可变，最长可达 40 字节。具体的选项字段，需要时再做介绍。

还记得我们在 IP 网际协议抓取的报文吗？我们下面再用 `tcpdump` 命令试着抓取一下。

```bash
sudo tcpdump -ntx -C 1
```

![实验楼](https://doc.shiyanlou.com/courses/98/923797/1e628dd88311e7d9484d1756c198dbcc-0/wm)

其实输出结果中还包含着 TCP 协议的报文，试着回顾一下，相信你能很快找到哪部分是 IP 协议的首部。IP 报文头紧接着的一部分就是 TCP 报文头，从 `170d` 开始。

> 源端口：`0x170d`，转换为十进制为 5901。
>
> 目的端口：`0x9d86`，即为 40326。
>
> 序号：`0xba42638b`，即为 3124913035，这和图中开头的 seq 是一致的。
>
> 确认序号：`0x4c1ad749`，即为 1276827465，这和图中开头的 ack 是一致的。
>
> 数据偏移：`0x8`，`8*4=32B`。
>
> 其他可依次类推。

### 连接的建立与释放

刚才说过，TCP 是面向连接的，在传输 TCP 报文段之前先要创建连接，发起连接的一方被称为客户端，而响应连接请求的一方被称为服务端，而这个创建连接的过程被称为**三次握手**：

![图片描述](https://dn-simplecloud.shiyanlou.com/uid/8797/1548922782588.png-wm)

- 客户端发出请求连接报文段，其中报头控制位 SYN=1，初始序号 seq=x。客户端进入 SYN-SENT(同步已发送)状态。
- 服务端收到请求报文段后，向客户端发送确认报文段。确认报文段的首部中 SYN=1，ACK=1，确认号是 ack=x+1，同时为自己选择一个初始序号 seq=y。服务端进入 SYN-RCVD（同步收到）状态。
- 客户端收到服务端的确认报文段后，还要给服务端发送一个确认报文段。这个报文段中 ACK=1，确认号 ack=y+1，而自己的序号 seq=x+1。**这个报文段已经可以携带数据，如果不携带数据则不消耗序号，则下一个报文段序号仍为 seq=x+1**。

至此 TCP 连接已经建立，客户端进入 ESTABLISHED（已建立连接）状态，当服务端收到确认后，也进入 ESTABLISHED 状态，它们之间便可以正式传输数据了。

当传输数据结束后，通信双方都可以释放连接，这个释放连接过程被称为**释放连接**:

![图片描述](https://dn-simplecloud.shiyanlou.com/uid/8797/1548923334867.png-wm)

- 此时 TCP 连接两端都还处于 ESTABLISHED 状态，客户端停止发送数据，并发出一个 FIN 报文段。首部 FIN=1，序号 seq=u（u 等于客户端传输数据最后一字节的序号加 1）。客户端进入 FIN-WAIT-1（终止等待 1）状态。
- 服务端回复确认报文段，确认号 ack=u+1，序号 seq=v（v 等于服务端传输数据最后一字节的序号加 1），服务端进入 CLOSE-WAIT（关闭等待）状态。现在 TCP 连接处于**半开半闭状态**，服务端如果继续发送数据，客户端依然接收。
- 客户端收到确认报文，进入 FIN-WAIT-2 状态，服务端发送完数据后，发出 FIN 报文段，FIN=1，确认号 ack=u+1，然后进入 LAST-ACK(最后确认)状态。
- 客户端回复确认报文段，ACK=1，确认号 ack=w+1（w 为半开半闭状态时，收到的最后一个字节数据的编号） ，序号 seq=u+1，然后进入 TIME-WAIT（时间等待）状态。

注意此时连接还没有释放，需要时间等待状态结束后（4 分钟）连接两端才会 CLOSED。设置时间等待是因为，有可能最后一个确认报文丢失而需要重传。

我们使用 tcpdump 命令抓包来理解握手过程。首先在终端输入如下命令：

```bash
sudo tcpdump -S host 192.168.42.3 and 121.40.227.60
```

>注意：此处的 192.168.42.3 要根据你自己的环境修改，为内网 ip，可以通过 ifconfig eth0 查看。121.40.227.60 是蓝桥云课的网址，需要通过 `nslookup www.lanqiao.cn` 命令查询最新的 IP 地址。

> 命令目的为抓取本机到 www.lanqiao.cn 的数据包；
>
> -S 参数的目的是获得 ack 的绝对值。

然后使用浏览器访问 `www.lanqiao.cn`。再回到终端，可以看到如下输出：

![图片描述](https://doc.shiyanlou.com/courses/98/923797/7d05c2b33722f3a2a629127bc5740894-0/wm)

输出中展示了三次握手的过程。红色为第一次，黄框是第二次，绿框是第三次，试着根据上面介绍的握手过程来对照 seq 和 ack 值的变化。

### TCP 可靠传输的实现

- TCP 报文段的长度可变，根据收发双方的缓存状态、网络状态而调整。
- 当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。
- 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段。这就是稍后介绍的**超时重传**。
- TCP 将保持它首部和数据的检验和。如果通过检验和发现报文段有差错，这个报文段将被丢弃，等待超时重传。
- TCP 将数据按字节排序，报文段中有序号，以确保顺序的正确性。
- TCP 还能提供流量控制。TCP 连接的每一方都有收发缓存。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。

可见超时重发机制是 TCP 可靠性的关键，只要没有得到确认报文段，就重新发送数据报，直到收到对方的确认为止。

### 超时重传

TCP 规定，接收者收到数据报文段后，需回复一个确认报文段，以告知发送者数据已经收到。而发送者如果一段时间内（**超时计时器**）没有收到确认报文段，便重复发送。

为了实现超时间重传，需要注意：

- 发送者发送一个报文段后，**暂时保存该报文段的副本**，为发生超时重传时使用，收到确认报文后删除该报文段。
- 确认报文段也需要序号，才能明确是发出去的哪个数据报得到了确认。
- 超时计时器比传输往返时间略长，但具体值是不确定的，根据网络情况而变。

### 连续 ARQ 协议

也许你也发现了，按上面的介绍，超时重传机制很费时间，每发送一个数据报都要等待确认。

在实际应用中的确不是这样的，真实情况是，采用了**流水线传输**：发送方可以连续发送多个报文段(连续发送的数据长度叫做窗口)，而不必每发完一段就停下来等待确认。

实际应用中，接收方也不必对收到的每个报文都做回复，而是采用**累积确认**方式：接收者收到多个连续的报文段后，只回复确认最后一个报文段，表示在这之前的数据都已收到。

这样，传输效率得到了很大的提升。

![图片描述](https://dn-simplecloud.shiyanlou.com/uid/8797/1548923960157.png-wm)

### 流量控制和拥塞控制

由于接收方缓存的限制，发送窗口不能大于接收方接收窗口。在报文段首部有一个字段就叫做**窗口(rwnd)**，这便是用于告诉对方自己的接收窗口，可见窗口的大小是可以变化的。

那么窗口的大小是如何变化的呢？TCP 对于拥塞的控制总结为“慢启动、加性增、乘性减”，如图所示：

![6-7-1](https://dn-simplecloud.shiyanlou.com/uid/8797/1548990633088.png-wm)

- **慢启动** ：初始的窗口值很小，但是按指数规律渐渐增长，直到达到**慢开始门限(ssthresh)**。
- **加性增** ：窗口值达到慢开始门限后，每发送一个报文段，窗口值增加一个单位量。
- **乘性减** ：无论什么阶段，只要出现超时，则把窗口值减小一半。

### tcpdump 抓取 TCP 报文段

上一节实验，我们用 tcpdump 抓取并阅读了 UDP 报文，那么这次我们尝试抓取 TCP 报文段。

针对这次实验，需要下载对应的代码文件，是基于 TCP 的聊天小程序，分为 server（服务端—）和 client（客户端）：

```bash
wget https://labfile.oss-internal.aliyuncs.com/courses/98/client.c
wget https://labfile.oss-internal.aliyuncs.com/courses/98/server.c
gcc -o server server.c
gcc -o client client.c
```

```checker
- name: check file
  script: |
    #!/bin/bash
    ls /home/project/server
  error: /home/project 目录下没有 server 文件
  timeout: 2
- name: check file
  script: |
    #!/bin/bash
    ls /home/project/client
  error: /home/project 目录下没有 client 文件
  timeout: 2
```

编译完成后先不要运行，先打开 tcpdump，使用命令安装并运行 tcpdump：

```bash
sudo apt-get update
sudo apt-get install tcpdump
sudo tcpdump -vvv -X -i lo tcp port 7777
```

新开一个终端，运行 server 程序：

```bash
./server 127.0.0.1
```

然后再新开第三个终端，运行 client 程序：

```bash
./client 127.0.0.1
```

现在，使用 client 和 server 聊天，轮流互发几条简短的消息（比如 hello、hi、wei 之类的）便可以关闭 client 和 server，回到运行 tcpdump 的终端查看抓取的报文段内容：

![6-8-1](https://doc.shiyanlou.com/TCP_IP/tcp-6-08.png/wm)

通过抓取的报文，还可以清晰的看到建立连接三次握手和断开连接四次握手的过程。

## 作业

1. 按实验步骤，使用 tcpdump 抓取 TCP 报文段，观察三次握手建立连接和四次握手释放连接的过程，并截图。
2. 使用实验给出的聊天程序收发消息，用 tcpdump 抓取包含聊天内容的 TCP 报文段，解读聊天内容，并截图。
