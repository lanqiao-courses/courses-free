---
show: step
version: 1.0
enable_checker: true
---

# C 语言数组

## 实验介绍

#### 实验简介

到现在可以说已经掌握了 C 语言最基础的部分，我们学习了 C 语言的数据类型、三大结构，这个时候可以说我们已经算是入门了。
但是这个时候我们其实远没有学到 C 语言的精彩部分，接下来我们将要讲述的数组就是 C 语言精彩部分的一节-数组。

#### 知识点

- 一维数组
- 二维数组
- 字符串数组

#### 代码获取

注：如果用的是实验 1 的环境则不需要重复此步骤。
你可以通过下面命令将本课程里的所有源代码下载到实验楼环境中，作为参照对比进行学习。

```bash
wget https://labfile.oss.aliyuncs.com/courses/57/c.zip
unzip -o c.zip
```

请尽量按照实验步骤自己写出 C 语言程序。

## 实验步骤

我们通过一个案例来简单的理解数组。班主任要计算班级里面 50 个同学四级考试的平均成绩，道理上讲这是一个比较简单的问题，只需要把每个人的成绩加起来除以 50 就可以了。

但是如何表示 50 个人的成绩呢？按照我们之前的逻辑定义 50 个变量，s1，s2，s3...s50，但是你有没有发现这样存在的问题？第一，这是 50 个学生，假如是 5000 个呢？这样定义很繁琐。第二，这样的定义没有反应出他们之间内在的联系，他们都是一个班级的，都是统计的四级成绩，这样的问题如何解决呢？

首先我们可以用同一个名字表示他们（如 S<sub></sub>），而在名字的右下角加一个数字来表示这是第几名学生的成绩，例如，可以用 S<sub>1</sub>，S<sub>2</sub>，S<sub>3</sub> 代表学生 1、学生 2、学生 3 直到学生 50 等 50 个学生的成绩。这个右下角的数字常称为下标。一批具有同名的同属性的数据就组成一个数组（array），就是数组名。

我们首先从一维数组来理解和学习。

### 一维数组

#### 定义一维数组

定义一维数组的一般形式为：

> **类型符 数组名[常量表达式]**

例如定义以下数组：

```c
int student[10];
```

**注意：**

- 数组名的命名规则和变量名相同，遵循标识符命名规则。
- 在定义数组时，需要指定数组中元素的个数，方括号中的常量表达式用来表示元素的个数，即数组长度。例如，在定义时定义 student[10]，表示数组 student[] 有 10 个元素。注意，下标是从 0 开始的，这 10 个元素分别是 student[0]...student[9]。一定要注意这里面不会有 student[10]。
- 常量表达式中可以包括常量和符号变量，如 `int a[4*2]` 是合法的。但是不能包括变量，如下面的就是不合法的：

```c
int n;
scanf("%d",&n);
int b[n];
```

经过上面的定义，在内存中划出一片存储空间（空间大小：4\*10 = 40 字节），存放一个含有 10 个整形元素的数组。

![8-2.1.1-1](https://doc.shiyanlou.com/c/7-13.jpg/wm)

#### 一维数组的初始化

为了让程序简洁，我们常常在定义数组的同时，给各数组元素赋值，这就是数组的初始化。

> 1. 在定义数组时对全部数组元素赋予初值。例如：
>
> > ```c
> > int a[10] = {0,1,2,3,4,5,6,7,8,9}；
> > ```
>
> 经过上面的定义并初始化之后，a[0]=0，a[1]=1，a[2]=2，a[3]=3，a[4]=4，a[5]=5，a[6]=6，a[7]=7，a[8]=8，a[9]=9。
>
> 2. 给数组中的部分元素赋值，例如：
>    > ```c
>    > int a[10] = {0,1,2,3};
>    > ```
>
> 定义 a 数组有 10 个元素，但是花括号内只给了 4 个初值，这表示只给前 4 个元素赋初值，其余元素系统自动给其赋初值为 0。

#### 一维数组举例

1. 定义一个含有 10 个元素的数组，依次赋值为 1，2，3，4，5，6，7，8，9，10，然后按逆序输出。

**解题思路：**

要赋的值是 1~10，有一定规律，我们可以用循环来赋值。同样，用循环来输出这 10 个值，在输出时，先输出最后的元素，按下标从大到小输出这 10 个元素。

创建 8-1.c 文件并输入以下代码：

```c
#include<stdio.h>
int main(){
    int i,a[10];

    for(i=0;i<10;i++)
    	a[i] = i + 1;

    for(i=9;i>=0;i--)
    	printf("%d\t",a[i]);

    return 0;
}
```

```checker
- name: 检查文件是否存在
  script: |
    #!/bin/bash
    ls /home/project/8-1.c
  error: 我们发现你没有创建文件 8-1.c
```

输入以下命令编译并运行：

```bash
gcc -o 8-1 8-1.c
./8-1
```

结果如下：
![8-2.1.3-1](https://doc.shiyanlou.com/document-uid18510labid357timestamp1527234374960.png/wm)

2. 现在输入 10 个用户的有效学习时间，要求对它们按由小到大的顺序排序。

> 解题思路：这种问题是一个典型的排序问题，排序方法是一种重要且基本的算法，我们在此使用“冒泡排序法”，其思路为：每次将相邻两个数比较，将小的调到前面，如果有 6 个数：8，7，5，4，2，0。第一次先将最前面的两个数 8 和 7 对调（看下图）。第二次将第二个数和第三个数（8 和 5）对调。如此总计进行了 5 次，得到 7-5-4-2-0-8 的顺序，可以看到：最大的数 8 已经沉底，成为最下面的一个数，而小的数上升。经过第一轮（5 次比较）后，得到了最大的数 8。
>
> ![8-2.1.3-2](https://doc.shiyanlou.com/c/8-1.png/wm)
>
> 然后进行第二轮的比较（见下图），对余下的 7，5，4，2，0 进行新一轮的比较，以便使次大的数沉底。经过这一轮 4 次的比较与交换，得到次大的数 7。
>
> ![8-2.1.3-3](https://doc.shiyanlou.com/c/8-2.png/wm)
>
> 按照此规律进行下去，可以推知 6 个数需要比较 5 轮，其中第一轮需要比较 5 次，第二轮需要比较 4 次，以此类推，第五轮只需比较一次。
>
> 如果有 n 个数，则需要比较 n-1 轮，在第一轮需要进行 n-1 次两两比较，在第 j 轮中要进行 n-j 次的两两比较。
>
> 这种如水底的气泡逐步冒出水面一样，故称之为冒泡法。

**编写源程序 8-2.c：**

```c
#include<stdio.h>

int main(){
  int i,j,t,LearnTime[10];
  printf("please enter 10 number:\n");

  for(i=0;i<10;i++)
      scanf("%d",&LearnTime[i]);

  for(j=0;j<9;j++)	//9次外循环，9次比较
      for(i=0;i<9-j;i++)	//9-j次内循环
          if(LearnTime[i]>LearnTime[i+1])	//交换值
          {
              t=LearnTime[i];
              LearnTime[i] = LearnTime[i+1];
              LearnTime[i+1] = t;
          }
   printf("the sorted number:\n");
   for(i=0;i<10;i++)
       printf("%d\t",LearnTime[i]);

   return 0;
}
```

```checker
- name: 检查文件是否存在
  script: |
    #!/bin/bash
    ls /home/project/8-2.c
  error: 我们发现你没有创建文件 8-2.c
```

程序运行结果如下：

![8-2.1.3-4](https://doc.shiyanlou.com/document-uid18510labid357timestamp1527234437389.png/wm)

### 二维数组

很多问题需要我们用到二维数组，比如一个年级有 4 个班，每个班有 30 个人，需要统计每个班的学生成绩，这个时候就要用的二维数组。如果建立一个数组 `student[][]`，第一维用来表示第几班，二维用来表示第几号，比如 `student[2][3]` 表示 2 班的 3 号同学。

#### 定义二维数组

二维数组的定义方法和一维数组类似，其一般形式为：

> **类型说明符 数组名[常量表达式][常量表达式]**

例如：

```c
float a[3][4];
```

C 语言中，二维数组在内存中存放的顺序是按行存放的，即在内存中先顺序存放第一行元素，接着再来存放第二行元素。

假设数组存放是从 2000 开始的，一个元素占用 4 个字节，下图就是 a[3][4] 在内存中存放的具体形式。

![8-2.2.1-1](https://doc.shiyanlou.com/document-uid18510labid357timestamp1507706344501.png/wm)

#### 二维数组的初始化

1. 分行给二维数组赋初值。例如：

   > ```c
   > int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
   > ```
   >
   > 这种赋值方法比较直观，把第一个花括号的值给第 0 行元素，第 2 个花括号的值给第一行元素

2. 可以将所有的数据放在一个花括号内，例如：

   > ```c
   > int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
   > ```
   >
   > 效果和第一种相同。但是很显然第一种方式较好，一行对一行，界限很清楚。用第二种方法如果数据多，则会写成一大片，容易遗漏。

3. 可以对部分元素赋初值。例如：

   > ```c
   > int a[3][4]={{1},{3},{5}};
   > ```
   >
   > 它的作用是只给各行第 0 列的元素赋初值，其他元素默认为 0。赋初值后的结果为：
   >
   > ```txt
   > 1 0 0 0
   > 3 0 0 0
   > 5 0 0 0
   > ```

#### 二维数组的举例

有一个 3\*4 的矩阵，求出其中的最大值并输出最大值和其所在的行号和列号。

> 解题思路：先思考一下在打擂台的时候怎样确定最后的优胜者。先找出任一个人站在台上，第 2 个人上去与之比武，胜者留在台上。再上去第 3 个人，与台上的人比武，胜者留在台上，败者下台。以后每一个人都和当时留在台上的人比武。直到所有人都上台比过为止，最后留在台上的就是冠军，这中方法就是打擂台法。
>
> 我们本题目也采用打擂台算法。先让 a[0][0] 做“擂主”，把它的值赋给变量 max，max 用来存放当前已知的最大值，在开始时还未进行比较，把最前面的元素认为是当前最大值，然后让下一个元素 a[0][1] 和 max 比较，如果 a[0][1]>max，则把 a[0][1] 赋值给 max，取代 max 的原值。以后以此处理，直到全部比完之后，max 就是最大值。

**编写源程序 8-3.c：**

```c
#include<stdio.h>

int main(){
    int i,j,row = 0,colum = 0,max;
    int a[3][4] = {{3,4,16,2},{7,5,1,9},{11,23,3,8}};

    max = a[0][0];
    for(i=0;i<3;i++)
        for(j=0;j<4;j++)
            if(a[i][j]>max)
            {
                max = a[i][j];
                row = i;
                colum = j;
            }

    printf("max=%d\nrow=%d\ncolum=%d\n",max,row,colum);

    return 0;
}
```

```checker
- name: 检查文件是否存在
  script: |
    #!/bin/bash
    ls /home/project/8-3.c
  error: 我们发现你没有创建文件 8-3.c
```

运行结果为：

![8-2.2.3-1](https://doc.shiyanlou.com/document-uid600404labid357timestamp1531040712869.png/wm)

### 字符数组

前面我们已经讲解过，字符型数据是以字符的 ASCII 代码存储在存储单元中的，一般占一个字节。由于 ASCII 代码属于整数形式，因此，把字符型归纳为整数类型中的一种。
由于字符数据的应用十分广泛，尤其是作为字符串形式的使用，有其自己的特点，我们单独成节来讲述该内容。

注意：C 语言中没有字符串类型，字符串都是存储在字符型数组中的。

#### 字符数组的定义

定义字符数组的方法与定义数值型数组的方法类似：例如：

```c
char c[10];
```

以上就定义了 c[] 为字符数组，包含 10 个元素。

#### 字符数组的初始化

把各个字符以此赋给数组中各元素。例如：

```c
char c[10]={'I',' ','a','m',' ','h','a','p','p','y'};
```

把这 10 个字符以此赋给 c[0]~c[9] 这 10 个元素。

注意：上面例子中花括号提供的初值个数（即字符个数）等于数组长度，倘若花括号中的提供初值个数大于数组长度，则会出现语法错误。倘若初值个数小于数组长度，则只将这些字符赋给数组中前面那些元素，其余元素自动定为空字符（即'\0'）。例如：

```c
char c[10]={'I',' ','l','o','v','e',' ','c'};
```

![8-2.3.2-1](https://doc.shiyanlou.com/c/8-10.png/wm)

在定义数组时可以省略数组长度，系统会自动根据数组个数确定数组长度。例如：

```c
char c[]={'I',' ','a','m',' ','h','a','p','p','y'};
```

数组 c[] 的长度自动定为 10。这种方式不用人工去数字符的个数，尤其在赋初值字符个数不较多的情况下，比较方便。

例如，输出一个正方形。

**解题思路：**

先画出一个平面正方形图案，每行包含 5 个字符，其中有的是空白字符，有的是 '\*' 字符，定义一个字符型的二维数组并初始化，用 for 循环嵌套输出。

**编写源程序 8-4.c：**

```c
#include<stdio.h>

int main(){
    char c[ ][9]={
    {'*',' ','*',' ','*',' ','*',' ','*'},
    {'*',' ',' ',' ',' ',' ',' ',' ','*'},
    {'*',' ',' ',' ',' ',' ',' ',' ','*'},
    {'*',' ',' ',' ',' ',' ',' ',' ','*'},
    {'*',' ','*',' ','*',' ','*',' ','*'},
    };
    int i,j;

    for(i=0;i<5;i++)
    {
        for(j=0;j<9;j++)
            printf("%c",c[i][j]);
        printf("\n");
    }

    return 0;
}
```

补充一点：C 语言中，二维数组初始化的语句中可以不指定行数进行初始化，比如 `char c[ ][9]` 就省略了行数，编译器自动将其识别为 `char c[5][9]`。

```checker
- name: 检查文件是否存在
  script: |
    #!/bin/bash
    ls /home/project/8-4.c
  error: 我们发现你没有创建文件 8-4.c
```

运行结果：

![8-2.3.2-2](https://doc.shiyanlou.com/document-uid18510labid357timestamp1527234495198.png/wm)

#### 字符串和字符串结束标志

在 C 语言中，是将字符串作为字符数组来处理的。在平时的应用中，人们往往关心的是字符串的有效长度而不是字符数组的长度。例如，定义一个字符数组长度 50，而实际有效字符只有 30 个。为了测定字符串的实际长度，C 语言规定了一个“字符串结束标志（'\0'）”，以字符 '\0' 作为结束标志。

如果字符数组中存在若干字符，前面 9 个字符都不是空字符（'\0'），而第 10 个字符是 '\0'，则认为数组中有一个字符串，其有效字符为 9 个。
系统在用字符数组存储字符串常量时会自动加一个 '\0' 作为结束符。例如：

```c
printf("Shiyanlou");
```

在执行次语句时系统怎么知道该输出到哪里为止呢？实际上，在向内存中存储时，系统自动在最后一个字符 'u' 后面加一个 '\0' 作为字符串结束标志。在执行 `printf()` 函数时，每输出一个字符检查一次，看下一个字符是否为 '\0'，遇到 '\0' 就停止输出。

![8-2.3.3-1](https://doc.shiyanlou.com/c/8-12.png/wm)

有了上述理解，在对字符数组初始化的方法上面我们做出一些补充。例如：

```c
char[] = {"I love shiyanlou"};
```

我们也可以直接省去花括号：

```c
char[] = "I love shiyanlou";
```

这里不像之前单个字符作为字符数组的初值，而是用字符串作为初值（字符串做初值是用双撇号而不是单撇号）。这种方法更直观、更方便。

注意：此时数组的长度是 17，而不是 16，因为字符串常量的最后系统自动加了一个 '\0'。上面的初始化与下面的初始化等价的。

```c
char c[] = {'I',' ','l','o','v','e',' ','s','h','i','y','a','n','l','o','u','\0'};
```

和下面的这个不等价：

```c
char c[] = {'I',' ','l','o','v','e',' ','s','h','i','y','a','n','l','o','u'};
```

#### 字符数组的输入输出

- 字符数组的输入输可以像前面的输入输出数字一样，用格式输入输出控制符。

1. 逐个字符输入输出，用格式“%c”输入或者输出一个字符。
2. 将整个字符串一次输入或者输出，用“%s”格式符，例如：

   > ```c
   > char c[] = "shiyanlou";
   > printf("%s", c); 	//用%s格式符输入或输出字符串时，接受项是字符数组名
   > ```

   内存中数组 c 的存储情况：

   ![8-2.3.4-1](https://doc.shiyanlou.com/c/8-12.png/wm)

- 也可以用`puts` 和 `gets`函数。其一般形式如下：

  **puts（字符数组）**：其作用是将一个字符串输出到终端，因此该函数用的不是很多，我们可以编写小程序来体验。

  **gets（字符数组）**：其作用是从终端输入一个字符串到字符数组，并且得到一个函数值。

**编写源程序 8-5.c：**

```c
#include<stdio.h>
#include<string.h> //在使用字符串处理函数时，在程序文件的开头用 #include<string.h>
int main(){
   char str[] = "China\nChengdu";

   puts(str);
   printf("Enter a new string:");
   gets(str);	//有的编译器会报 warning，提示 gets() 函数不安全；
   				//这里说明一下，这个warning是编译器针对这个函数的，不影响实验。感兴趣的同学可以作为课后自学。
   puts(str);

   return 0;
}
```

```checker
- name: 检查文件是否存在
  script: |
    #!/bin/bash
    ls /home/project/8-5.c
  error: 我们发现你没有创建文件 8-5.c
```

运行结果为：

![8-2.3.4-2](https://doc.shiyanlou.com/document-uid18510labid357timestamp1527234520339.png/wm)

### 使用字符串处理函数

C 语言函数库中提供了一些用来专门处理字符串的函数，使用比较方便。

#### `strcat` 函数-字符串连接函数

其一般形式如下：

> **strcat（字符数组 1，字符数组 2）**

其作用是把两个字符数组中的字符串连接起来，把字符串 2 接到 1 后面，结果放到字符串 1 中。

**编写源程序 8-6.c：**

```c
#include<stdio.h>
#include<string.h> //在使用字符串处理函数时，在程序文件的开头用 #include<string.h>
int main(){
   char str1[30] = "People's Republic of'";
   char str2[] = "China";

   printf("%s",strcat(str1,str2));

   return 0;
}
```

```checker
- name: 检查文件是否存在
  script: |
    #!/bin/bash
    ls /home/project/8-6.c
  error: 我们发现你没有创建文件 8-6.c
```

运行结果：

![8-2.4.1-1](https://doc.shiyanlou.com/courses/1585/923797/840d47102ce0b0415a9e7d8442e83f0e-0/wm)

**注意：**

1. 连接前两个字符串后面都有 '\0'，连接时将字符串 1 后面的 '\0' 取消，只在新串后面保留 '\0'。
2. 字符串 1 必须足够大，以便于容纳字符串 2。如果在定义是定义为 `char str1[]="People's Republic of";` 就会出现问题，因为长度不够。

#### `strlen` 函数-测字符串长度的函数

其一般形式如下：

> **strlen(字符数组)**

它是测量字符串长度的函数。函数的值为字符串中的实际长度。例如：

```c
char str[] = "China";
printf("%d",strlen(str));
```

注意：strlen() 返回的值比实际占用的长度要小，因为不包含 '\0'。

#### `strcpy` ——字符串复制函数

其一般形式如下：

> **strcpy（字符串 1，字符串 2）**

作用是将字符串 2 复制到字符串 1 中。例如：

```c
char str1[10],str2[] = "China";
strcpy(str1,str2);
```

**注意：**

- 字符数组 1 必须定义的足够大，以便容纳被复制的字符串 2。
- “字符数组 1” 必须写成数组名形式（如 str1），“字符串 2”可以使字符数组名，也可以是一个字符串常量。例如：`strcpy(str1,"China");` 作用与前面的相同。
- 不能用赋值语句将一个字符串常量直接给一个字符数组。如下面两行是错误的：
  ```c
  str1 = "shiyanlou";  	//错误，企图用赋值语句将一个字符串常量直接赋值给一个数组
  str1 = str2;          	//错误，企图用赋值语句将一个字符数组直接赋给另一个字符数组
  ```

#### `strcmp`——字符串比较函数

其一般形式如下：

> **strcmp（字符串 1，字符串 2）**

它的作用是比较字符串 1 和字符串 2。例如：

```c
strcmp(str1,str2);
strcmp("Chengdu","Beijing");
```

**比较规则**：

将两个字符串自左向右逐个字符比较（按照 ASCII 码值大小比较），直到出现不同的字符或者遇到 '\0 '为止。

1. 如果全部字符相同，则认为两个字符串相同。
2. 若出现不同的字符，则以第 1 对不相同的字符的比较结果为准。例如："A"<"D"，"e">"E"，"these">"that"，"computer">"compare"。
3. 比较结果由函数值带回。
   - 字符串 1=字符串 2，则函数值为 0
   - 字符串 1>字符串 2，则函数值为一个正整数
   - 字符串 1<字符串 2，则函数值为一个负整数

关于字符串处理函数，还有 `strlwr` 函数（转换为小写的函数）、`strupr` 函数（转换为大写的函数）`strncpy` 函数等其它函数，我们这里不再一一阐述，有兴趣的小伙伴可以查询相关内容。

### 字符数组应用举例

任意键入 3 个字符串，编程找出最小的一个。

**编写源程序 8-7.c：**

```c
#include<stdio.h>
#include<string.h>

int main(){
    char string[30];
    // 定义一个二维数组
    // ch[1]、ch[2]、ch[3] 都是一个字符数组，相当于三个字符串
    char ch[3][30];
    int i;
    // 循环读取三行，并且将每行存到 ch[i] 中
    for(i=0;i<3;i++)
        gets(ch[i]);
    strcpy(string,ch[0]);
    for(i=1;i<3;i++)
        if(strcmp(ch[i],string)<0)
            strcpy(string,ch[i]);
    printf("The result is :\n%s",string);

    return 0;
}
```

这里要注意的是，我们定义的 ch[1]、ch[2]、ch[3] 都只有 30 个字符大小，`gets()` 函数还会自动补 `\0`，因此我们每行的输入不要超过 29 个字符。

```checker
- name: 检查文件是否存在
  script: |
    #!/bin/bash
    ls /home/project/8-7.c
  error: 我们发现你没有创建文件 8-7.c
```

运行结果为：

![8-2.4.4-1](https://doc.shiyanlou.com/document-uid18510labid357timestamp1527234583058.png/wm)

## 实验总结

本节课讲述的内容较多,需要大家多多练习方可掌握，接下来的练习题大家也务必自己独立思考并完成程序编写才能融会贯通，掌握数组知识。

## 课后练习题

#### 习题一

输入 20 个实数存放在一维数组中，输出它们的平均值以及高于平均的数的个数。

#### 习题二

围绕着山顶有 10 个洞，一只兔子和一只狐狸住在各自的洞里，狐狸总想吃掉兔子，一天兔子对狐狸说，你想吃我有一个条件，你先把洞编号 1 到 10，你从第 10 洞出发，先到第 1 号洞找我，第二次隔一个洞找我，第三次隔两个洞找我，以后依次类推，次数不限，若能找到我你就可以饱餐一顿，在没找到我之前不能停止，狐狸一想只有 10 个洞，寻找的次数又不限，哪有找不到的道理，就答应了条件，结果狐狸跑得昏了过去也没找到兔子，请问兔子躲在哪个洞里。程序中可假定狐狸找了 1000 次。

### 参考答案

#### 习题一

```c
#include<stdio.h>

int main(){
    int num[20];
    int ave,sum;
    int flag = 0;               //大于平均数的个数

    //输入
    for(int i=0;i<20;i++)
        scanf("%d",&num[i]);

    //求和
    for(int i=0;i<20;i++)
        sum += num[i];

    ave = sum / 20;

    for(int i=0;i<20;i++)
       if(num[i]>ave)
            flag++;

    printf("ave=%d,num bigger than ave is %d",ave,flag);

    return 0;
}

```

#### 习题二

```c
#include<stdio.h>

int main(){
    int hole[10],i,n = 0;

    for(i=0;i<10;i++)
        hole[i] = 0;                    //为每个洞赋值为0，代表狐狸未找过该洞

    for(i=0;i<1000;i++)                 //用循环实现狐狸找1000次洞
    {
        n = n % 10;                      //n为狐狸当前寻找的洞的编号（实际编号应为n+1）
        hole[n] = 1;                    //为找过的洞赋值为1，代表狐狸已经找过该洞
        n = n + i + 2;                     //设置下一次寻找的编号
    }

    printf("The hole's numbers are:");

    for(i=0;i<10;i++)                   //逐个输出洞的编号（实际编号）
    {
        if(hole[i]==0)
        {
            printf("%d ",i + 1);
        }
    }

    return 0;
}
```
